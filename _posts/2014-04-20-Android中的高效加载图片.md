
本文是我参考Android的官方文档写的，官网[地址](https://developer.android.com/training/displaying-bitmaps/index.html)    

# 高效加载图片  

![我的头像]({{ site.baseurl }}/assets/head.jpg '可选的标题')  
一般来说现在的手机拍照的图片动辄几兆甚至十几兆，对于Android手机来说默认的单个应用的可分配的内存只有16M，所以说如何处理图片是  
android 上一个不小的难题。
根据不同的图片来源（有网络的图片、本地图片等）Android官方提供了BitmapFactory 这个工具类，可以使用decodeByteArray(),   decodeFile(), decodeResource()等用来生成Bitmap，但是这里面如果图片的资源过大非常容易导致OOM。下面的写法是比较通用的避免类似的问题。  
{% highlight java %}
	BitmapFactory.Options options = new BitmapFactory.Options();  
	options.inJustDecodeBounds = true;  
	BitmapFactory.decodeResource(getResources(), R.id.myimage, options);  
	int imageHeight = options.outHeight;  
	int imageWidth = options.outWidth;  
	String imageType = options.outMimeType;  
{% endhighlight %}
这里面主要通过设置 options.inJustDecodeBounds = true;让我们不但可以读出资源图片的type,宽和高，而且最重要的是不会产生实际的bitmap,换句话说就是不会占用内存，也就不会出现OOM的情况。
拿到图片的宽高，再去做处理就比较简单了，不过也要根据不同的需求做不同的处理（主要根据需求：例如显示在多大的imagview上面，屏幕的尺  寸和分辨率。。。）。
使用inSampleSize 对图片进行等比压缩。例如：inSampleSize=4，就是把图片压缩为原来的1/4。
	public static int calculateInSampleSize(
	    BitmapFactory.Options options, int reqWidth, int reqHeight) {
	// Raw height and width of image
	final int height = options.outHeight;
	final int width = options.outWidth;
	int inSampleSize = 1;

	if (height > reqHeight || width > reqWidth) {

	final int halfHeight = height / 2;
	final int halfWidth = width / 2;

	// Calculate the largest inSampleSize value that is a power of 2 and keeps both
	// height and width larger than the requested height and width.
	while ((halfHeight / inSampleSize) > reqHeight
	        && (halfWidth / inSampleSize) > reqWidth) {
	    inSampleSize *= 2;
	}
	}

	return inSampleSize;
	}


	public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
	    int reqWidth, int reqHeight) {

	// First decode with inJustDecodeBounds=true to check dimensions
	final BitmapFactory.Options options = new BitmapFactory.Options();
	options.inJustDecodeBounds = true;
	BitmapFactory.decodeResource(res, resId, options);

	// Calculate inSampleSize
	options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

	// Decode bitmap with inSampleSize set
	options.inJustDecodeBounds = false;
	return BitmapFactory.decodeResource(res, resId, options);
	}
	mImageView.setImageBitmap(
	decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));

这里面演示的是使用本地的资源图片，真正使用过程中会加载各种资源，根据资源的不同使用BitmapFactory.decode的不  
同的方法就可以了。



